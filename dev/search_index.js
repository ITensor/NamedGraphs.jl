var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#NamedGraphs.DefaultNamedCapacity","page":"Reference","title":"NamedGraphs.DefaultNamedCapacity","text":"DefaultNamedCapacity{T}\n\nStructure that returns 1 if a forward edge exists in flow_graph, and 0 otherwise.\n\n\n\n\n\n","category":"type"},{"location":"reference/#NamedGraphs.NamedDijkstraState","page":"Reference","title":"NamedGraphs.NamedDijkstraState","text":"struct NamedDijkstraState{V,T}\n\nAn AbstractPathState designed for Dijkstra shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"reference/#NamedGraphs.edgeinduced_subgraphs_no_leaves-Tuple{NamedGraphs.AbstractNamedGraph, Int64}","page":"Reference","title":"NamedGraphs.edgeinduced_subgraphs_no_leaves","text":"edgeinduced_subgraphs_no_leaves(g::AbstractNamedGraph, max_number_of_edges::Int64)\n\nEnumerate all unique, connected edgesubgraphs without any leaf vertices (degree 1) and with Nedges <= maxnumberof_edges\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.CURRENT_PARTITIONING_BACKEND","page":"Reference","title":"NamedGraphs.GraphsExtensions.CURRENT_PARTITIONING_BACKEND","text":"Current default graph partitioning backend\n\n\n\n\n\n","category":"constant"},{"location":"reference/#NamedGraphs.GraphsExtensions.Backend","page":"Reference","title":"NamedGraphs.GraphsExtensions.Backend","text":"Graph partitioning backend\n\n\n\n\n\n","category":"type"},{"location":"reference/#NamedGraphs.GraphsExtensions.add_edges!-Tuple{Graphs.AbstractGraph, Any}","page":"Reference","title":"NamedGraphs.GraphsExtensions.add_edges!","text":"Add a list of edges to a graph g\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.current_partitioning_backend-Tuple{}","page":"Reference","title":"NamedGraphs.GraphsExtensions.current_partitioning_backend","text":"Get the graph partitioning backend\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.distance_to_leaves-Tuple{Graphs.AbstractGraph, Any}","page":"Reference","title":"NamedGraphs.GraphsExtensions.distance_to_leaves","text":"Get distance of a vertex from a leaf\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.has_leaf_neighbor-Tuple{Graphs.AbstractGraph, Any}","page":"Reference","title":"NamedGraphs.GraphsExtensions.has_leaf_neighbor","text":"Determine if a node has any neighbors which are leaves\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.incident_edges-Tuple{Graphs.AbstractGraph, Any}","page":"Reference","title":"NamedGraphs.GraphsExtensions.incident_edges","text":"incident_edges(graph::AbstractGraph, vertex; dir=:out)\n\nEdges incident to the vertex vertex.\n\ndir âˆˆ (:in, :out, :both), defaults to :out.\n\nFor undirected graphs, returns all incident edges.\n\nLike: https://juliagraphs.org/Graphs.jl/v1.7/algorithms/linalg/#Graphs.LinAlg.adjacency_matrix\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.is_cycle_graph-Union{Tuple{var\"##286\"}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{var\"##286\"}}}, var\"##286\"}} where var\"##286\"","page":"Reference","title":"NamedGraphs.GraphsExtensions.is_cycle_graph","text":"https://juliagraphs.org/Graphs.jl/dev/corefunctions/simplegraphsgenerators/#Graphs.SimpleGraphs.cyclegraph-Tuple%7BT%7D%20where%20T%3C:Integer https://en.wikipedia.org/wiki/Cyclegraph\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.is_leaf_edge-Union{Tuple{var\"##291\"}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{var\"##291\"}}}, var\"##291\", Graphs.AbstractEdge}} where var\"##291\"","page":"Reference","title":"NamedGraphs.GraphsExtensions.is_leaf_edge","text":"Determine if an edge involves a leaf (at src or dst)\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.is_path_graph-Union{Tuple{var\"##285\"}, Tuple{Type{SimpleTraits.Not{Graphs.IsDirected{var\"##285\"}}}, var\"##285\"}} where var\"##285\"","page":"Reference","title":"NamedGraphs.GraphsExtensions.is_path_graph","text":"Check if an undirected graph is a path/linear graph:\n\nhttps://en.wikipedia.org/wiki/Path_graph\n\nbut not a path/linear forest:\n\nhttps://en.wikipedia.org/wiki/Linear_forest\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.non_leaf_edges-Tuple{Graphs.AbstractGraph}","page":"Reference","title":"NamedGraphs.GraphsExtensions.non_leaf_edges","text":"Get all edges which do not involve a leaf\n\nhttps://en.wikipedia.org/wiki/Tree(graphtheory)#Definitions\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.random_bfs_tree-Tuple{Graphs.AbstractGraph, Any}","page":"Reference","title":"NamedGraphs.GraphsExtensions.random_bfs_tree","text":"Do a BFS search to construct a tree, but do it with randomness to avoid generating the same tree. Based on Int. J. Comput. Their Appl. 15 pp 177-186 (2008). Edges will point away from source vertex s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.rem_edges!-Tuple{Graphs.AbstractGraph, Any}","page":"Reference","title":"NamedGraphs.GraphsExtensions.rem_edges!","text":"Remove a list of edges from a graph g\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.rem_vertices!-Tuple{Graphs.AbstractGraph, Any}","page":"Reference","title":"NamedGraphs.GraphsExtensions.rem_vertices!","text":"Remove a list of vertices from a graph g\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.root_vertex-Union{Tuple{var\"##296\"}, Tuple{Type{Graphs.IsDirected{var\"##296\"}}, var\"##296\"}} where var\"##296\"","page":"Reference","title":"NamedGraphs.GraphsExtensions.root_vertex","text":"Return the root vertex of a rooted directed graph.\n\nThis will return the first root vertex that is found, so won't error if there is more than one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.set_partitioning_backend!-Tuple{Union{Missing, String, NamedGraphs.GraphsExtensions.Backend}}","page":"Reference","title":"NamedGraphs.GraphsExtensions.set_partitioning_backend!","text":"Set the graph partitioning backend\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.NamedGraphGenerators.named_hexagonal_lattice_graph-Tuple{Integer, Integer}","page":"Reference","title":"NamedGraphs.NamedGraphGenerators.named_hexagonal_lattice_graph","text":"Generate a graph which corresponds to a hexagonal tiling of the plane. There are m rows and n columns of hexagons. Based off of the generator in Networkx hexagonallatticegraph()\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.NamedGraphGenerators.named_triangular_lattice_graph-Tuple{Integer, Integer}","page":"Reference","title":"NamedGraphs.NamedGraphGenerators.named_triangular_lattice_graph","text":"Generate a graph which corresponds to a equilateral triangle tiling of the plane. There are m rows and n columns of triangles. Based off of the generator in Networkx triangularlatticegraph()\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.PartitionedGraphs","page":"Reference","title":"NamedGraphs.PartitionedGraphs","text":"module PartitionedGraphs\n\nA library for partitioned graphs and their quotients.\n\nThis module provides data structures and functionalities to work with partitioned graphs, including quotient vertices and edges, as well as views of partitioned graphs. It defines an abstract supertype AbstractPartitionedGraph for graphs that have some notion of a non-trivial partitioning of their vertices. It also provides  a interface of functions that can be overloaded on any subtype of Graphs.AbstractGraph to make this subtype behave like a partitioned graph, without itself subtyping AbstractPartitionedGraph.\n\nIt defines the following concrete types:\n\nQuotientVertex: Represents a vertex in the quotient graph.\nQuotientEdge: Represents an edge in the quotient graph.\nPartitionedView: A lightweight view of a partitioned graph.\nPartitionedGraph: An implementation of a partitioned graph with extra caching   not provided by PartitionedView.\nQuotientView: A view of the quotient graph derived from a partitioned graph.\n\nIt provides the following functions:\n\npartitionedgraph: Partitions an AbstractGraph.\ndepartition: Removes a single layer of partitioning from a partitioned graph.\nunpartition: Recursively removes all layers of partitioning from a partitioned graph.\n\nInterfaces\n\nFor a type MyGraphType{V} <: Graphs.AbstractGraph{V}, to have a non-trivial partitioning then the interface can be summarized as follows:\n\n# 1. If you want a non-trivial partitioning, then overload the method:\npartitioned_vertices(g::MyGraphType)\n\n# 2a. For fast quotient graph construction and fast `has_edge` at the quotient_graph level:\nquotient_graph(g::MyGraphType)\n# 2b. If Julia is unable to infer the returned type of `quotient_graph` then you should\n# also define the `quotient_graph_type` function:\nquotient_graph_type(g::MyGraphType)\n\n# 3. For a fast vertex to quotient-vertex map then:\nquotientvertex(g::MyGraphType, vertex)\n# ...which automatically gives a fast edge to quotient-edge map via:\nquotientedge(g, edge) # no need to overload this.\n\n# 4. For fast finding of edge partitions: \npartitioned_edges(g::MyGraphType)\n\nIf any of the above properties are desirable for MyGraphType, then store the data in a  field and overload the associated function to get that field, e.g.\n\nquotientvertex(g::MyGraphType, vertex) = g.inverse_vertex_map[vertex]\n\nwhere we have chosen to store the map in the field inverse_vertex_map of the MyGraphType type.  Doing this is not essential as everything can and will be derived from partitioned_vertices as a fallback.\n\nInterface for adding and removing vertices\n\nFor a given partitioned graph, all vertices must live in a quotient vertex and there should be no empty quotient vertices. The methods:\n\nGraphs.rem_vertex!(g::MyGraphType, vertex)\nGraphs.add_edge!(g::MyGraphType, edge)\nGraphs.rem_edge!(g::MyGraphType, edge)\n\nshould be overloaded to ensure that these properties are maintained for the particular  implementation of MyGraphType.  Note, that the method:\n\nGraphs.add_vertex!(g::MyGraphType, vertex)\n\nis not supported for partitioned graphs as it is ambiguous which quotient vertex the new vertex should belong to. To add a vertex to a partitioned graph, one should define the method:\n\nGraphs.add_subquotientvertex!(g::MyGraphType, quotientvertex::QuotientVertex, vertex)\n\nDoing so enables the syntax:\n\nGraphs.add_vertex!(graph, QuotientVertex(quotientvertex)[vertex])\n\nfor adding vertex to the quotient vertex quotientvertex in the partitioned graph.\n\n\n\n\n\n","category":"module"},{"location":"reference/#NamedGraphs.PartitionedGraphs.AbstractPartitionedGraph","page":"Reference","title":"NamedGraphs.PartitionedGraphs.AbstractPartitionedGraph","text":"abstract type AbstractPartitionedGraph{V, PV} <: AbstractNamedGraph{V}\n\nTo use AbstractPartitionedGraph one should defined unpartitioned_graph that returns an underlying graph without any partitioning. One should also define:\n\n\n\n\n\n","category":"type"},{"location":"reference/#NamedGraphs.PartitionedGraphs.QuotientEdge","page":"Reference","title":"NamedGraphs.PartitionedGraphs.QuotientEdge","text":"QuotientEdge(e)\n\nRepresents a super-edge in a partitioned graph corresponding to the set of edges in between partitions src(e) and dst(e).\n\n\n\n\n\n","category":"type"},{"location":"reference/#NamedGraphs.PartitionedGraphs.QuotientVertex","page":"Reference","title":"NamedGraphs.PartitionedGraphs.QuotientVertex","text":"QuotientVertex(v)\n\nRepresents a super-vertex in a partitioned graph corresponding to the set of vertices in partition v.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Graphs.edges-Tuple{Graphs.AbstractGraph, NamedGraphs.PartitionedGraphs.QuotientEdge}","page":"Reference","title":"Graphs.edges","text":"edges(g::AbstractGraph, quotientedge::QuotientEdge)\nedges(g::AbstractGraph, quotientedges::QuotientEdges)\n\nReturn the set of edges in the graph g that correspond to a single quotient edge or a list of quotient edges.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.ne-Tuple{Graphs.AbstractGraph, NamedGraphs.PartitionedGraphs.QuotientEdge}","page":"Reference","title":"Graphs.ne","text":"ne(g::AbstractGraph, qe::QuotientEdge) -> Int\n\nReturns the number of edges in g that correspond to the quotient edge qe.\n\nSee also: nv.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Graphs.vertices-Tuple{Graphs.AbstractGraph, NamedGraphs.PartitionedGraphs.QuotientVertex}","page":"Reference","title":"Graphs.vertices","text":"vertices(g::AbstractGraph, quotientvertex::QuotientVertex)\nvertices(g::AbstractGraph, quotientvertices::Vector{QuotientVertex})\n\nReturn the set of vertices in the graph g associated with the quotient vertex quotientvertex or set of quotient vertices quotientvertices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.GraphsExtensions.rem_edges!-Tuple{Graphs.AbstractGraph, NamedGraphs.PartitionedGraphs.QuotientEdge}","page":"Reference","title":"NamedGraphs.GraphsExtensions.rem_edges!","text":"rem_edges!(g::AbstractGraph, qe::QuotientEdge) -> Int\n\nRemove, in place, all the edges of g that correspond to the quotient edge qe.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.PartitionedGraphs.has_quotientedge-Tuple{Graphs.AbstractGraph, NamedGraphs.PartitionedGraphs.QuotientEdge}","page":"Reference","title":"NamedGraphs.PartitionedGraphs.has_quotientedge","text":"has_quotientedge(g::AbstractGraph, qe::QuotientEdge) -> Bool\n\nReturns true if the quotient edge qe exists in the quotient graph of g.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.PartitionedGraphs.quotientedge-Tuple{Graphs.AbstractGraph, Pair}","page":"Reference","title":"NamedGraphs.PartitionedGraphs.quotientedge","text":"quotientedge(g::AbstractGraph{V}, edge) -> QuotientEdge{V}\n\nReturn the the quotient edge corresponding to edge of the graph g. Note, the returned quotient edge may be a self-loop.\n\nSee also: quotientedges, quotienttvertex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.PartitionedGraphs.quotientedges-Tuple{Graphs.AbstractGraph}","page":"Reference","title":"NamedGraphs.PartitionedGraphs.quotientedges","text":"quotientedges(g::AbstractGraph, es = edges(pg)) -> QuotientEdges\n\nReturn an iterator over all unique quotient edges corresponding to the set of edges es of the graph g.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.PartitionedGraphs.quotientvertices-Tuple{Any}","page":"Reference","title":"NamedGraphs.PartitionedGraphs.quotientvertices","text":"quotientvertices(g::AbstractGraph, vs = vertices(pg))\n\nReturn an iterator over unique quotient vertices corresponding to the set vertices vs of the graph pg.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NamedGraphs.Keys.Key","page":"Reference","title":"NamedGraphs.Keys.Key","text":"Key{K}\n\nA key (index) type, used for unambiguously identifying an object as a key or index of an indexible object AbstractArray, AbstractDict, etc.\n\nUseful for nested structures of indices, for example:\n\n[Key([1, 2]), [Key([3, 4]), Key([5, 6])]]\n\nwhich could represent partitioning a set of vertices\n\n[Key([1, 2]), Key([3, 4]), Key([5, 6])]\n\n\n\n\n\n","category":"type"},{"location":"#NamedGraphs.jl","page":"Home","title":"NamedGraphs.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n\nNamedGraphs.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"The package can be added as usual through the package manager:\n\njulia> Pkg.add(\"NamedGraphs\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using NamedGraphs: NamedGraphs\n\nExamples go here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
