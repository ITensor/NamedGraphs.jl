var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = NamedGraphs","category":"page"},{"location":"#NamedGraphs","page":"Home","title":"NamedGraphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for NamedGraphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [NamedGraphs]","category":"page"},{"location":"#NamedGraphs.DefaultNamedCapacity","page":"Home","title":"NamedGraphs.DefaultNamedCapacity","text":"DefaultNamedCapacity{T}\n\nStructure that returns 1 if a forward edge exists in flow_graph, and 0 otherwise.\n\n\n\n\n\n","category":"type"},{"location":"#NamedGraphs.Key","page":"Home","title":"NamedGraphs.Key","text":"Key{K}\n\nA key (index) type, used for unambiguously identifying an object as a key or index of an indexible object AbstractArray, AbstractDict, etc.\n\nUseful for nested structures of indices, for example:\n\n[Key([1, 2]), [Key([3, 4]), Key([5, 6])]]\n\nwhich could represent partitioning a set of vertices\n\n[Key([1, 2]), Key([3, 4]), Key([5, 6])]\n\n\n\n\n\n","category":"type"},{"location":"#NamedGraphs.NamedDijkstraState","page":"Home","title":"NamedGraphs.NamedDijkstraState","text":"struct NamedDijkstraState{V,T}\n\nAn AbstractPathState designed for Dijkstra shortest-paths calculations.\n\n\n\n\n\n","category":"type"},{"location":"#NamedGraphs.add_edges!-Tuple{Graphs.AbstractGraph, Any}","page":"Home","title":"NamedGraphs.add_edges!","text":"Add a list of edges to a graph g\n\n\n\n\n\n","category":"method"},{"location":"#NamedGraphs.hexagonal_lattice_graph-Tuple{Int64, Int64}","page":"Home","title":"NamedGraphs.hexagonal_lattice_graph","text":"Generate a graph which corresponds to a hexagonal tiling of the plane. There are m rows and n columns of hexagons. Based off of the generator in Networkx hexagonallatticegraph()\n\n\n\n\n\n","category":"method"},{"location":"#NamedGraphs.incident_edges-Tuple{Graphs.AbstractGraph, Any}","page":"Home","title":"NamedGraphs.incident_edges","text":"incident_edges(graph::AbstractGraph, vertex; dir=:out)\n\nEdges incident to the vertex vertex.\n\ndir âˆˆ (:in, :out, :both), defaults to :out.\n\nFor undirected graphs, returns all incident edges.\n\nLike: https://juliagraphs.org/Graphs.jl/v1.7/algorithms/linalg/#Graphs.LinAlg.adjacency_matrix\n\n\n\n\n\n","category":"method"},{"location":"#NamedGraphs.is_path_graph-Tuple{Graphs.AbstractGraph}","page":"Home","title":"NamedGraphs.is_path_graph","text":"TODO: Make this more sophisticated, check that only two vertices have degree 1 and none have degree 0, meaning it is a path/linear graph:\n\nhttps://en.wikipedia.org/wiki/Path_graph\n\nbut not a path/linear forest:\n\nhttps://en.wikipedia.org/wiki/Linear_forest\n\n\n\n\n\n","category":"method"},{"location":"#NamedGraphs.random_bfs_tree-Tuple{Graphs.AbstractGraph, Any}","page":"Home","title":"NamedGraphs.random_bfs_tree","text":"Do a BFS search to construct a tree, but do it with randomness to avoid generating the same tree. Based on Int. J. Comput. Their Appl. 15 pp 177-186 (2008). Edges will point away from source vertex s.\n\n\n\n\n\n","category":"method"},{"location":"#NamedGraphs.rem_edges!-Tuple{Graphs.AbstractGraph, Any}","page":"Home","title":"NamedGraphs.rem_edges!","text":"Remove a list of edges from a graph g\n\n\n\n\n\n","category":"method"},{"location":"#NamedGraphs.rem_vertices!-Tuple{Graphs.AbstractGraph, Any}","page":"Home","title":"NamedGraphs.rem_vertices!","text":"Remove a list of vertices from a graph g\n\n\n\n\n\n","category":"method"},{"location":"#NamedGraphs.triangular_lattice_graph-Tuple{Int64, Int64}","page":"Home","title":"NamedGraphs.triangular_lattice_graph","text":"Generate a graph which corresponds to a equilateral triangle tiling of the plane. There are m rows and n columns of triangles. Based off of the generator in Networkx triangularlatticegraph()\n\n\n\n\n\n","category":"method"}]
}
